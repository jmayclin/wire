use crate::{
    decryption::{key_space::KeySpace, Mode},
    iana::{self},
    key_log::NssLog,
};
use std::{
    collections::HashMap,
    ffi::c_void,
    fmt::Debug,
    pin::Pin,
    sync::{Arc, Mutex},
};

#[derive(Debug, Clone, PartialEq, Eq, Hash, Default)]
struct TlsKeys {
    /// TLS 1.3
    pub client_handshake_traffic_secret: Option<Vec<u8>>,
    pub server_handshake_traffic_secret: Option<Vec<u8>>,
    pub client_application_traffic_secret: Option<Vec<u8>>,
    pub server_application_traffic_secret: Option<Vec<u8>>,
    /// TLS 1.2-ish
    pub master_secret: Option<Vec<u8>>,
}

impl TlsKeys {
    fn update_from_nss_log(&mut self, keys: NssLog) -> anyhow::Result<()> {
        match keys.label.as_str() {
            "CLIENT_HANDSHAKE_TRAFFIC_SECRET" => {
                self.client_handshake_traffic_secret = Some(keys.secret);
            }
            "SERVER_HANDSHAKE_TRAFFIC_SECRET" => {
                self.server_handshake_traffic_secret = Some(keys.secret);
            }
            "CLIENT_TRAFFIC_SECRET_0" => {
                self.client_application_traffic_secret = Some(keys.secret);
            }
            "SERVER_TRAFFIC_SECRET_0" => {
                self.server_application_traffic_secret = Some(keys.secret);
            }
            "CLIENT_RANDOM" => {
                self.master_secret = Some(keys.secret);
            }
            _ => {}
        }
        Ok(())
    }
}

/// The KeyManager holds all of the keys that are generated by the key logging callbacks.
/// This has been primarily designed to work with s2n-tls's key logging, but should
/// work with other implementations as well.
///
/// The KeyManager is internally reference counter and can be safely shared across
/// connections.
///
/// Notes that a single KeyManager is generally set on a config but decrypting is
/// done per-connection, so that is a one-to-many relationship.
///
/// The `Pin` is necessary for safe use with s2n-tls, which will case the reference
/// to a c_void pointer.
#[derive(Debug, Clone)]
pub struct KeyManager(Pin<Arc<Mutex<HashMap<Vec<u8>, TlsKeys>>>>);

impl Default for KeyManager {
    fn default() -> Self {
        Self::new()
    }
}

impl KeyManager {
    pub fn new() -> Self {
        let value = Arc::pin(Mutex::new(HashMap::new()));
        Self(value)
    }

    pub fn enable_s2n_logging(&self, config: &mut s2n_tls::config::Builder) {
        unsafe {
            config
                .set_key_log_callback(
                    Some(Self::s2n_tls_key_log_cb),
                    self as *const KeyManager as *mut c_void,
                )
                .unwrap();
        }
    }

    unsafe extern "C" fn s2n_tls_key_log_cb(
        ctx: *mut std::ffi::c_void,
        _conn: *mut s2n_tls_sys::s2n_connection,
        logline: *mut u8,
        len: usize,
    ) -> std::ffi::c_int {
        let handle = &mut *(ctx as *mut Self);
        let logline = core::slice::from_raw_parts(logline, len);

        // ignore any errors
        handle.parse_key_log_line(logline);

        0
    }

    /// This signature is required by OpenSSL
    pub fn parse_key_log_line(&self, line: &[u8]) {
        let line = String::from_utf8(line.to_vec()).unwrap();
        let key = NssLog::from_log_line(&line).unwrap();
        self.register_key(key);
    }

    pub fn register_key(&self, key: NssLog) {
        tracing::debug!("received key {key:?}");
        self.0
            .lock()
            .unwrap()
            .entry(key.client_random.clone())
            .or_default()
            .update_from_nss_log(key)
            .unwrap();
    }

    /// the key used for initial handshake messages in TLS 1.3
    pub fn handshake_space(
        &self,
        mode: Mode,
        client_random: &[u8],
        cipher: iana::Cipher,
    ) -> Option<KeySpace> {
        let key = self.0.lock().unwrap().get(client_random)?.clone();
        let secret = match mode {
            Mode::Client => key.client_handshake_traffic_secret?,
            Mode::Server => key.server_handshake_traffic_secret?,
        };
        let space = KeySpace::handshake_traffic_secret(secret, cipher);
        Some(space)
    }

    /// Retrieve the KeySpace for a particular application space.
    ///
    /// Index will be `0` for the initial set of traffic keys, but higher indicies
    /// will be used in the event of key updates.
    pub fn first_application_space(
        &self,
        mode: Mode,
        client_random: &[u8],
        cipher: iana::Cipher,
    ) -> Option<KeySpace> {
        let key = self.0.lock().unwrap().get(client_random)?.clone();
        let secret = match mode {
            Mode::Client => key.client_application_traffic_secret?,
            Mode::Server => key.server_application_traffic_secret?,
        };
        let space = KeySpace::first_traffic_secret(secret, cipher);
        Some(space)
    }
}

impl rustls::KeyLog for KeyManager {
    fn log(&self, label: &str, client_random: &[u8], secret: &[u8]) {
        let key = NssLog {
            label: label.to_string(),
            client_random: client_random.to_vec(),
            secret: secret.to_vec(),
        };
        self.register_key(key)
    }
}
