use crate::{
    codec::{DecodeValue, DecodeValueWithContext, EncodeValue},
    decryption::s2n_tls_intercept::{generic_recv_cb, generic_send_cb},
    iana::{self, Protocol},
    key_log::NssLog,
    protocol::{
        content_value::{ContentValue, HandshakeMessageValue},
        Alert, ChangeCipherSpec, ContentType, RecordHeader,
    },
};
use aws_lc_rs::{
    aead,
    hkdf::{self},
};
use std::{
    collections::HashMap,
    ffi::c_void,
    fmt::Debug,
    io::{Read, Write},
    pin::Pin,
    sync::{Arc, Mutex},
};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Mode {
    Client,
    Server,
}

impl Mode {
    pub fn peer(&self) -> Mode {
        match self {
            Mode::Client => Mode::Server,
            Mode::Server => Mode::Client,
        }
    }
}

impl iana::Cipher {
    fn aead(&self) -> &'static aws_lc_rs::aead::Algorithm {
        match self.description {
            "TLS_AES_128_GCM_SHA256" => &aead::AES_128_GCM,
            "TLS_AES_256_GCM_SHA384" => &aead::AES_256_GCM,
            "TLS_CHACHA20_POLY1305_SHA256" => &aead::CHACHA20_POLY1305,
            _ => panic!("one of us did something stupid. Probably me."),
        }
    }

    fn hkdf(&self) -> aws_lc_rs::hkdf::Algorithm {
        match self.description {
            "TLS_AES_128_GCM_SHA256" => hkdf::HKDF_SHA256,
            "TLS_AES_256_GCM_SHA384" => hkdf::HKDF_SHA384,
            "TLS_CHACHA20_POLY1305_SHA256" => hkdf::HKDF_SHA256,
            _ => panic!("one of us did something stupid. Probably me."),
        }
    }
}

/// The KeyManager holds all of the keys that are generated by the key logging callbacks.
/// This has been primarily designed to work with s2n-tls's key logging, but should
/// work with other implementations as well.
///
/// The KeyManager is internally reference counter and can be safely shared across
/// connections.
///
/// Notes that a single KeyManager is generally set on a config but decrypting is
/// done per-connection, so that is a one-to-many relationship.
///
/// The `Pin` is necessary for safe use with s2n-tls, which will case the reference
/// to a c_void pointer.
#[derive(Debug, Clone)]
pub struct KeyManager(Pin<Arc<Mutex<HashMap<Vec<u8>, TlsKeys>>>>);

#[derive(Debug, Clone, PartialEq, Eq, Hash, Default)]
struct TlsKeys {
    /// TLS 1.3
    pub client_handshake_traffic_secret: Option<Vec<u8>>,
    pub server_handshake_traffic_secret: Option<Vec<u8>>,
    pub client_application_traffic_secret: Option<Vec<u8>>,
    pub server_application_traffic_secret: Option<Vec<u8>>,
    /// TLS 1.2-ish
    pub master_secret: Option<Vec<u8>>,
}

impl TlsKeys {
    fn update_from_nss_log(&mut self, keys: NssLog) -> anyhow::Result<()> {
        match keys.label.as_str() {
            "CLIENT_HANDSHAKE_TRAFFIC_SECRET" => {
                self.client_handshake_traffic_secret = Some(keys.secret);
            }
            "SERVER_HANDSHAKE_TRAFFIC_SECRET" => {
                self.server_handshake_traffic_secret = Some(keys.secret);
            }
            "CLIENT_TRAFFIC_SECRET_0" => {
                self.client_application_traffic_secret = Some(keys.secret);
            }
            "SERVER_TRAFFIC_SECRET_0" => {
                self.server_application_traffic_secret = Some(keys.secret);
            }
            "CLIENT_RANDOM" => {
                self.master_secret = Some(keys.secret);
            }
            _ => {}
        }
        Ok(())
    }
}

impl KeyManager {
    pub fn new() -> Self {
        let value = Arc::pin(Mutex::new(HashMap::new()));
        Self(value)
    }

    pub fn enable_s2n_logging(&self, config: &mut s2n_tls::config::Builder) {
        unsafe {
            config
                .set_key_log_callback(
                    Some(Self::s2n_tls_key_log_cb),
                    self as *const KeyManager as *mut c_void,
                )
                .unwrap();
        }
    }

    unsafe extern "C" fn s2n_tls_key_log_cb(
        ctx: *mut std::ffi::c_void,
        _conn: *mut s2n_tls_sys::s2n_connection,
        logline: *mut u8,
        len: usize,
    ) -> std::ffi::c_int {
        let handle = &mut *(ctx as *mut Self);
        let logline = core::slice::from_raw_parts(logline, len);

        // ignore any errors
        handle.parse_key_log_line(logline);

        0
    }

    fn parse_key_log_line(&self, line: &[u8]) {
        let line = String::from_utf8(line.to_vec()).unwrap();
        let key = NssLog::from_log_line(&line).unwrap();
        self.0
            .lock()
            .unwrap()
            .entry(key.client_random.clone())
            .or_default()
            .update_from_nss_log(key)
            .unwrap();
    }

    /// the key used for initial handshake messages in TLS 1.3
    fn handshake_space(&mut self, client_random: &[u8], cipher: iana::Cipher) -> Option<KeySpace> {
        let key = self.0.lock().unwrap().get(client_random)?.clone();
        let space = KeySpace::new(
            key.client_handshake_traffic_secret?,
            key.server_handshake_traffic_secret?,
            cipher,
        );
        Some(space)
    }

    fn application_space(
        &mut self,
        client_random: &[u8],
        cipher: iana::Cipher,
    ) -> Option<KeySpace> {
        let key = self.0.lock().unwrap().get(client_random)?.clone();
        let space = KeySpace::new(
            key.client_application_traffic_secret?,
            key.server_application_traffic_secret?,
            cipher,
        );
        Some(space)
    }
}

#[derive(Debug)]
struct KeySpace {
    cipher: iana::Cipher,
    client_secret: Vec<u8>,
    server_secret: Vec<u8>,
    client_record_count: u64,
    server_record_count: u64,
}

struct UsizeContainer(usize);

impl UsizeContainer {
    fn new(num: usize) -> Self {
        UsizeContainer(num)
    }
}

// they have unfortunately made me too angry to put up with their API
// I am done asking nicely, and will simply transmute it into the shape
// I wish for, and deal with the consequences later.
impl hkdf::KeyType for UsizeContainer {
    fn len(&self) -> usize {
        self.0
    }
}

fn hkdf_expand_label<T: hkdf::KeyType>(
    secret: &[u8],
    label: &[u8],
    context: &[u8],
    key_type: T,
    hkdf: hkdf::Algorithm,
) -> Vec<u8> {
    let prk = hkdf::Prk::new_less_safe(hkdf, secret);

    let output_length_bytes = (key_type.len() as u16).to_be_bytes();
    let label = {
        let mut label_builder = Vec::new();
        label_builder.extend_from_slice(b"tls13 ");
        label_builder.extend_from_slice(label);
        label_builder
    };
    let label_bytes = label.len() as u8;

    let context_bytes = context.len() as u8;
    let label = [
        output_length_bytes.as_slice(),
        &[label_bytes],
        &label,
        &[context_bytes],
        context,
    ];

    let mut key = vec![0; key_type.len()];
    let out = prk.expand(&label, key_type).unwrap();
    out.fill(&mut key).unwrap();
    key
}

trait KeySpaceTrait {
    fn new(secret: &[u8]) -> Self;

    fn decrypt_record(&mut self, record: &[u8]);
}

impl KeySpace {
    fn new(client_secret: Vec<u8>, server_secret: Vec<u8>, cipher: iana::Cipher) -> Self {
        // https://www.rfc-editor.org/rfc/rfc8446#section-7.3
        // [sender]_write_key = HKDF-Expand-Label(Secret, "key", "", key_length)
        // [sender]_write_iv  = HKDF-Expand-Label(Secret, "iv", "", iv_length)

        Self {
            cipher,
            client_secret,
            server_secret,
            client_record_count: 0,
            server_record_count: 0,
        }
    }

    fn traffic_key(&self, mode: Mode) -> std::io::Result<(Vec<u8>, Vec<u8>)> {
        let secret = match mode {
            Mode::Client => self.client_secret.as_slice(),
            Mode::Server => self.server_secret.as_slice(),
        };
        // Determine the hash algorithm, key length, and IV length based on the cipher suite
        let aead = self.cipher.aead();

        let key = hkdf_expand_label(
            secret,
            b"key",
            b"",
            UsizeContainer::new(aead.key_len()),
            self.cipher.hkdf(),
        );
        let iv = hkdf_expand_label(
            secret,
            b"iv",
            b"",
            UsizeContainer::new(aead.nonce_len()),
            self.cipher.hkdf(),
        );

        Ok((key, iv))
    }

    /// * `record`: the encrypted record, exclusive of the header
    /// * `sender`: the party who transmitted the record
    fn decrypt_record(&mut self, header: &RecordHeader, record: &[u8], sender: Mode) -> Vec<u8> {
        let (key, iv) = self.traffic_key(sender).unwrap();

        let record_count = match sender {
            Mode::Client => &mut self.client_record_count,
            Mode::Server => &mut self.server_record_count,
        };
        let nonce = Self::calculate_nonce(iv, *record_count);
        *record_count += 1;

        let unbound_key = aws_lc_rs::aead::UnboundKey::new(self.cipher.aead(), &key).unwrap();
        let less_safe_key = aws_lc_rs::aead::LessSafeKey::new(unbound_key);

        // Create a buffer that contains ciphertext + tag for in-place decryption
        let mut output = record.to_vec();

        // Decrypt the record
        let nonce_obj = aws_lc_rs::aead::Nonce::try_assume_unique_for_key(&nonce).unwrap();

        let aad = header.encode_to_vec().unwrap();

        let plaintext = less_safe_key
            .open_in_place(nonce_obj, aws_lc_rs::aead::Aad::from(aad), &mut output)
            .unwrap();
        plaintext.to_vec()
    }

    /// XOR the IV with the record count
    fn calculate_nonce(iv: Vec<u8>, record_count: u64) -> Vec<u8> {
        let mut nonce = iv.clone();
        let record_count = record_count.to_be_bytes();
        let mut bytes = vec![0; nonce.len() - record_count.len()];
        bytes.extend_from_slice(&record_count);

        for i in 0..nonce.len() {
            nonce[i] ^= bytes[i];
        }

        nonce
    }
}

/// The StreamDecrypter is responsible for actually decrypting the TLS traffic
///
/// The decrypt pipeline goes
/// 1. tx_byte_buffer: data is buffered here until a complete record has been gathered
/// 2. tx_record_buffer: records are buffered here until a complete message can be read
///
/// TODO: This representation is a poor one for the eldritch nightmare that is technically
/// allowed by TLS record framing
/// ```text
/// |   message 1 |  message 2  | message 3  |
/// |  r1   |   r2      |     r3    |   r4   |
/// ```
/// I affectionately refer to this as "polyrhythm records".
///
/// We currently just assume that messages fit in a record which is very not right.
/// We probably want to adapt the tx_record_buffer to be a stream of the concatenated
/// plaintexts from the decrypted records that we receive
/// stream[space][content_type]
pub struct StreamDecrypter {
    /// The identity of this decrypter, either "client" or "server".
    ///
    /// We need to track this because we need to map send/recv data onto client/server
    /// specific keys.
    ///
    /// This is deduced from first IO. If the first IO is receiving, then we are
    /// a server. If the first IO is sending, then we are a client.
    pub identity: Option<Mode>,
    pub client_random: Option<Vec<u8>>,

    selected_cipher: Option<iana::Cipher>,
    selected_protocol: Option<Protocol>,

    /// all tx calls are buffered here until there is enough to read a message
    server_tx_byte_buffer: Vec<u8>,
    client_tx_byte_buffer: Vec<u8>,

    /// records, populated from tx
    server_tx_record_buffer: Vec<Vec<u8>>,
    client_tx_record_buffer: Vec<Vec<u8>>,

    // these are the "real" send and read callbacks that the client wants to use.
    // In the case of s2n-tls, I plan to steal them from inside the bindings.
    // intercepted_send: Box<dyn std::io::Write>,
    // intercepted_read: Box<dyn std::io::Read>,
    key_manager: KeyManager,
    // TODO: 2 different key spaces for client and server. They could stack key
    // updates on top of each other and we need to be able to handle that.
    current_space: Option<KeySpace>,

    pub transcript: Vec<(Mode, ContentValue)>,
}

impl StreamDecrypter {
    pub fn new(
        // send: Box<dyn std::io::Write>,
        // read: Box<dyn std::io::Read>,
        key_manager: KeyManager,
    ) -> Self {
        Self {
            identity: None,
            client_random: None,
            selected_cipher: None,
            selected_protocol: None,
            server_tx_byte_buffer: Vec::new(),
            client_tx_byte_buffer: Vec::new(),
            server_tx_record_buffer: Vec::new(),
            client_tx_record_buffer: Vec::new(),
            // intercepted_send: send,
            // intercepted_read: read,
            key_manager,
            current_space: None,
            transcript: Vec::new(),
        }
    }

    /// Record a transmitted bytes.
    ///
    /// To record received bytes, this method can just be called with a swapped
    /// mode. E.g. Receiving bytes from the client can be recorded as a client
    /// transmissions.
    pub fn record_tx(&mut self, bytes: &[u8], sender: Mode) {
        match sender {
            Mode::Client => self.client_tx_byte_buffer.extend_from_slice(bytes),
            Mode::Server => self.server_tx_byte_buffer.extend_from_slice(bytes),
        };
    }

    pub fn dump_transcript(&self, file: &str) {
        let transcript = format!("{:#?}", self.transcript);
        std::fs::write(file, transcript).unwrap();
    }

    // pub fn enable_s2n_connection_decryption(
    //     decrypter: &Box<Self>,
    //     connection: &mut s2n_tls::connection::Connection,
    // ) {
    //     connection
    //         .set_send_callback(Some(generic_send_cb::<StreamDecrypter>))
    //         .unwrap();
    //     connection
    //         .set_receive_callback(Some(generic_recv_cb::<StreamDecrypter>))
    //         .unwrap();
    //     unsafe {
    //         connection
    //             .set_send_context(decrypter.as_ref() as *const StreamDecrypter as *mut c_void)
    //             .unwrap();
    //         connection
    //             .set_receive_context(decrypter.as_ref() as *const StreamDecrypter as *mut c_void)
    //             .unwrap();
    //     }
    // }

    pub fn assemble_records(&mut self, mode: Mode) -> std::io::Result<()> {
        // TODO: error handling. We currently assume that all errors are just because
        // there isn't enough data. Which will not be true into the future. Also
        // should think more about the "not enough data" error.

        let (raw, records) = match mode {
            Mode::Client => (
                &mut self.client_tx_byte_buffer,
                &mut self.client_tx_record_buffer,
            ),
            Mode::Server => (
                &mut self.server_tx_byte_buffer,
                &mut self.server_tx_record_buffer,
            ),
        };

        // multiple records may have been sent, so loop
        loop {
            let buffer = raw.as_slice();
            let (record_header, buffer) = RecordHeader::decode_from(buffer)?;
            if buffer.len() >= record_header.record_length as usize {
                // TODO: use split off for better performance
                let (record_contents, remaining) =
                    raw.split_at(5 + record_header.record_length as usize);
                records.push(record_contents.to_vec());
                *raw = remaining.to_vec();
            } else {
                // there wasn't enough to get the full record
                break;
            }
        }

        Ok(())
    }

    pub fn decrypt_records(&mut self, mode: Mode) -> std::io::Result<()> {
        // for each record
        println!("------------ {mode:?} ------------");
        let records = match mode {
            Mode::Client => &mut self.client_tx_record_buffer,
            Mode::Server => &mut self.server_tx_record_buffer,
        };

        for record in records.drain(..) {
            let record_buffer = record.as_slice();
            let (record_header, mut record_buffer) = RecordHeader::decode_from(record_buffer)?;
            println!("{record_header:#?}");

            // read all of the messages in the buffer
            while !record_buffer.is_empty() {
                record_buffer = match record_header.content_type {
                    ContentType::Invalid => panic!("invalid content"),
                    ContentType::ChangeCipherSpec => {
                        let (ccs, record_buffer) = ChangeCipherSpec::decode_from(record_buffer)?;
                        println!("{ccs:?}");
                        record_buffer
                    }
                    ContentType::Alert => {
                        let (alert, record_buffer) = Alert::decode_from(record_buffer)?;
                        println!("{alert:?}");
                        self.transcript.push((mode, ContentValue::Alert(alert)));
                        record_buffer
                    }
                    ContentType::Handshake => {
                        let (handshake_message, record_buffer) =
                            match (self.selected_protocol, self.selected_cipher) {
                                (Some(protocol), Some(cipher)) => {
                                    HandshakeMessageValue::decode_from_with_context(
                                        record_buffer,
                                        (protocol, cipher),
                                    )?
                                }
                                _ => HandshakeMessageValue::decode_from(record_buffer)?,
                            };

                        // extra the client random from the client hello
                        if let HandshakeMessageValue::ClientHello(ch) = &handshake_message {
                            self.client_random = Some(ch.random.to_vec())
                        }

                        // the server hello sets most of the relevant cryptographic state
                        if let HandshakeMessageValue::ServerHello(sh) = &handshake_message {
                            self.selected_cipher = Some(sh.cipher_suite);
                            self.selected_protocol = Some(sh.selected_version()?);
                        }

                        println!("{handshake_message:?}");
                        self.transcript
                            .push((mode, ContentValue::Handshake(handshake_message)));

                        record_buffer
                    }
                    ContentType::ApplicationData => {
                        // TODO: I think I need two separate spaces.
                        if self.current_space.is_none() {
                            self.current_space = self.key_manager.handshake_space(
                                self.client_random.as_ref().unwrap(),
                                self.selected_cipher.unwrap(),
                            );
                        }
                        // check if keys are available
                        // if let Some(space) = self
                        //     .key_manager
                        //     .handshake_space(self.selected_cipher.unwrap())
                        // {
                        //     self.current_space = Some(space);
                        // }

                        println!("{} bytes of ApplicationData", record_buffer.len());
                        let space = self.current_space.as_mut().unwrap();
                        let mut plaintext =
                            space.decrypt_record(&record_header, record_buffer, mode);

                        // TODO explain wth is happening here.
                        let mut padding = 0;
                        while plaintext.ends_with(&[0]) {
                            padding += 1;
                            plaintext.remove(plaintext.len() - 1);
                        }

                        let (content_type, _buffer) =
                            ContentType::decode_from(&plaintext[plaintext.len() - 1..])?;

                        // drop the content byte from the end
                        let plaintext = &plaintext[..(plaintext.len() - 1)];

                        println!("InnerRecordHeader {{");
                        println!("    content_type: {content_type:?}");
                        println!("    inner_length: {}", plaintext.len());
                        println!("    padding: {padding}");
                        println!("}}");
                        let inner_plaintext = plaintext;

                        let (value, buffer) = match content_type {
                            ContentType::Invalid => panic!("invalid"),
                            ContentType::ChangeCipherSpec => panic!("invalid inner CCS"),
                            ContentType::Alert => {
                                let (alert, buffer) = Alert::decode_from(inner_plaintext)?;
                                println!("{alert:?}");
                                (ContentValue::Alert(alert), buffer)
                            }
                            ContentType::Handshake => {
                                let (handshake_message, inner_buffer) =
                                    match (self.selected_protocol, self.selected_cipher) {
                                        (Some(protocol), Some(cipher)) => {
                                            HandshakeMessageValue::decode_from_with_context(
                                                inner_plaintext,
                                                (protocol, cipher),
                                            )?
                                        }
                                        _ => HandshakeMessageValue::decode_from(inner_plaintext)?,
                                    };
                                // if it was the client finished, time for application secrets
                                if matches!(handshake_message, HandshakeMessageValue::Finished(_))
                                    && mode == Mode::Client
                                {
                                    self.current_space = self.key_manager.application_space(
                                        self.client_random.as_ref().unwrap(),
                                        self.selected_cipher.unwrap(),
                                    );
                                }
                                (ContentValue::Handshake(handshake_message), inner_buffer)
                            }
                            ContentType::ApplicationData => (
                                ContentValue::ApplicationData(inner_plaintext.to_vec()),
                                [].as_slice(),
                            ),
                        };
                        self.transcript.push((mode, value));

                        &[]
                    }
                };
            }
        }

        Ok(())
    }
}

impl Debug for StreamDecrypter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("StreamDecrypter")
            .field("raw_client_tx", &self.client_tx_byte_buffer.len())
            .field("raw_server_tx", &self.server_tx_byte_buffer.len())
            .field("client_record_tx", &self.client_tx_record_buffer.len())
            .field("server_record_tx", &self.server_tx_record_buffer.len())
            .finish()
    }
}

// designed to work with an IO callback based pattern, such as that used by s2n-tls
// and OpenSSL
// impl std::io::Read for StreamDecrypter {
//     fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
//         if self.identity.is_none() {
//             // reading first is server behavior
//             self.identity = Some(Mode::Server);
//         }

//         let read = self.intercepted_read.read(buf)?;

//         match self.identity.unwrap() {
//             Mode::Client => self.server_tx_byte_buffer.extend_from_slice(&buf[..read]),
//             Mode::Server => self.client_tx_byte_buffer.extend_from_slice(&buf[..read]),
//         }

//         let peer = self.identity.unwrap().peer();
//         self.assemble_records(peer);
//         self.decrypt_records(peer);

//         Ok(read)
//     }
// }

// impl std::io::Write for StreamDecrypter {
//     fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
//         if self.identity.is_none() {
//             // writing first is client behavior
//             self.identity = Some(Mode::Client);
//         }

//         let written = self.intercepted_send.write(buf)?;

//         match self.identity.unwrap() {
//             Mode::Client => self.client_tx_byte_buffer.extend_from_slice(&buf[..written]),
//             Mode::Server => self.server_tx_byte_buffer.extend_from_slice(&buf[..written]),
//         }

//         self.assemble_records(self.identity.unwrap());
//         self.decrypt_records(self.identity.unwrap());

//         Ok(written)
//     }

//     fn flush(&mut self) -> std::io::Result<()> {
//         /* no op */
//         Ok(())
//     }
// }

#[cfg(test)]
mod s2n_tls_decryption {
    use crate::{
        decryption::{
            s2n_tls_intercept::{intercept_recv_callback, intercept_send_callback, ArchaicCPipe},
            DecryptingPipe,
        },
        protocol::HandshakeMessageHeader,
    };

    use super::*;

    use s2n_tls::testing::TestPair;

    #[test]
    fn traffic_key_derivation() {
        let server_secret =
            hex::decode("4182e4b0b6565a8f7b8586cc35d2ca23f22fa47764a16eaee9e1b21038efd2a4")
                .unwrap();
        let client_secret =
            hex::decode("8bf4b07633e7de6b46e2a680713d8b0b8b9bcc9592163b8fa32222d650b005f3")
                .unwrap();

        let space = KeySpace::new(
            client_secret,
            server_secret,
            iana::Cipher::from_description("TLS_AES_128_GCM_SHA256").unwrap(),
        );

        let (key, iv) = space.traffic_key(Mode::Server).unwrap();
        assert_eq!(hex::encode(key), "d4af18cdaa11d3943b4d8bb0f9d6c6ca");
        assert_eq!(hex::encode(iv), "32bd8d44d91fb6e913c3349b");
    }

    #[test]
    fn handshake_record_decrypt() {
        let server_secret =
            hex::decode("64d7b60c7f0d3ca90e47411c575f7eaa8b24d754f3e68ac2d3f060e28395553d")
                .unwrap();
        let client_secret =
            hex::decode("8bf4b07633e7de6b46e2a680713d8b0b8b9bcc9592163b8fa32222d650b005f3")
                .unwrap();

        let aes_128 = iana::Cipher::from_description("TLS_AES_128_GCM_SHA256").unwrap();

        let mut space = KeySpace::new(client_secret, server_secret, aes_128);

        let record =
            hex::decode("1703030017c89a8a469e34ecee23cd8fbe8e978763ac2e498ddebcc5").unwrap();
        let record_buffer = record.as_slice();
        let (record_header, record_buffer) = RecordHeader::decode_from(record_buffer).unwrap();

        let decrypted = space.decrypt_record(&record_header, record_buffer, Mode::Server);
        assert_eq!(hex::encode(decrypted), "08000002000016");
    }

    #[test]
    fn maybe_app_data() {
        let data = hex::decode("08000002000016").unwrap();

        let (header, buffer) = HandshakeMessageHeader::decode_from(data.as_slice()).unwrap();
        println!("header : {header:#?}");
    }
}
