use crate::{
    codec::{DecodeValue, DecodeValueWithContext, EncodeValue},
    iana::{self, Protocol},
    key_log::NssLog,
    protocol::{
        content_value::HandshakeMessageValue, Alert, ChangeCipherSpec, ContentType, RecordHeader,
    },
};
use aws_lc_rs::{
    aead,
    hkdf::{self},
};
use std::{
    collections::HashMap, ffi::c_int, fmt::Debug, io::{ErrorKind, Read, Write}, os::raw::c_void, pin::Pin, sync::{Arc, Mutex}
};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum Mode {
    Client,
    Server,
}

impl Mode {
    fn peer(&self) -> Mode {
        match self {
            Mode::Client => Mode::Server,
            Mode::Server => Mode::Client,
        }
    }
}

impl iana::Cipher {
    fn aead(&self) -> &'static aws_lc_rs::aead::Algorithm {
        match self.description {
            "TLS_AES_128_GCM_SHA256" => &aead::AES_128_GCM,
            "TLS_AES_256_GCM_SHA384" => &aead::AES_256_GCM,
            "TLS_CHACHA20_POLY1305_SHA256" => &aead::CHACHA20_POLY1305,
            _ => panic!("one of us did something stupid. Probably me."),
        }
    }

    fn hkdf(&self) -> aws_lc_rs::hkdf::Algorithm {
        match self.description {
            "TLS_AES_128_GCM_SHA256" => hkdf::HKDF_SHA256,
            "TLS_AES_256_GCM_SHA384" => hkdf::HKDF_SHA384,
            "TLS_CHACHA20_POLY1305_SHA256" => hkdf::HKDF_SHA256,
            _ => panic!("one of us did something stupid. Probably me."),
        }
    }
}

/// The KeyManager holds all of the keys that are generated by the key logging callbacks.
/// This has been primarily designed to work with s2n-tls's key logging, but should
/// work with other implementations as well.
/// 
/// The KeyManager is internally reference counter and can be safely shared across
/// connections.
///
/// Notes that a single KeyManager is generally set on a config but decrypting is
/// done per-connection, so that is a one-to-many relationship.
/// 
/// The `Pin` is necessary for safe use with s2n-tls, which will case the reference
/// to a c_void pointer.
#[derive(Debug, Clone)]
struct KeyManager(Pin<Arc<Mutex<HashMap<Vec<u8>, TlsKeys>>>>);

#[derive(Debug, Clone, PartialEq, Eq, Hash, Default)]
struct TlsKeys {
    /// TLS 1.3
    pub client_handshake_traffic_secret: Option<Vec<u8>>,
    pub server_handshake_traffic_secret: Option<Vec<u8>>,
    pub client_application_traffic_secret: Option<Vec<u8>>,
    pub server_application_traffic_secret: Option<Vec<u8>>,
    /// TLS 1.2-ish
    pub master_secret: Option<Vec<u8>>,
}

impl TlsKeys {
    fn update_from_nss_log(&mut self, keys: NssLog) -> anyhow::Result<()> {
        match keys.label.as_str() {
            "CLIENT_HANDSHAKE_TRAFFIC_SECRET" => {
                self.client_handshake_traffic_secret = Some(keys.secret);
            }
            "SERVER_HANDSHAKE_TRAFFIC_SECRET" => {
                self.server_handshake_traffic_secret = Some(keys.secret);
            }
            "CLIENT_TRAFFIC_SECRET_0" => {
                self.client_application_traffic_secret = Some(keys.secret);
            }
            "SERVER_TRAFFIC_SECRET_0" => {
                self.server_application_traffic_secret = Some(keys.secret);
            }
            "CLIENT_RANDOM" => {
                self.master_secret = Some(keys.secret);
            }
            _ => {}
        }
        Ok(())
    }
}

impl KeyManager {
    fn new() -> Self {
        let value = Arc::pin(Mutex::new(HashMap::new()));
        Self(value)
    }
    unsafe extern "C" fn key_log_cb(
        ctx: *mut std::ffi::c_void,
        _conn: *mut s2n_tls_sys::s2n_connection,
        logline: *mut u8,
        len: usize,
    ) -> std::ffi::c_int {
        let handle = &mut *(ctx as *mut Self);
        let logline = core::slice::from_raw_parts(logline, len);

        // ignore any errors
        handle.parse_key_log_line(logline);

        0
    }

    fn parse_key_log_line(&self, line: &[u8]) {
        let line = String::from_utf8(line.to_vec()).unwrap();
        let key = NssLog::from_log_line(&line).unwrap();
        self.0
            .lock()
            .unwrap()
            .entry(key.client_random.clone())
            .or_default()
            .update_from_nss_log(key);
    }

    /// the key used for initial handshake messages in TLS 1.3
    fn handshake_space(&mut self, client_random: &[u8], cipher: iana::Cipher) -> Option<KeySpace> {
        let key = self.0.lock().unwrap().get(client_random)?.clone();
        let space = KeySpace::new(
            key.client_handshake_traffic_secret?,
            key.server_handshake_traffic_secret?,
            cipher,
        );
        Some(space)
    }

    fn application_space(
        &mut self,
        client_random: &[u8],
        cipher: iana::Cipher,
    ) -> Option<KeySpace> {
        let key = self.0.lock().unwrap().get(client_random)?.clone();
        let space = KeySpace::new(
            key.client_application_traffic_secret?,
            key.server_application_traffic_secret?,
            cipher,
        );
        Some(space)
    }
}

#[derive(Debug)]
struct KeySpace {
    cipher: iana::Cipher,
    client_secret: Vec<u8>,
    server_secret: Vec<u8>,
    client_record_count: u64,
    server_record_count: u64,
}

struct UsizeContainer(usize);

impl UsizeContainer {
    fn new(num: usize) -> Self {
        UsizeContainer(num)
    }
}

// they have unfortunately made me too angry to put up with their API
// I am done asking nicely, and will simply transmute it into the shape
// I wish for, and deal with the consequences later.
impl hkdf::KeyType for UsizeContainer {
    fn len(&self) -> usize {
        self.0
    }
}

fn hkdf_expand_label<T: hkdf::KeyType>(
    secret: &[u8],
    label: &[u8],
    context: &[u8],
    key_type: T,
    hkdf: hkdf::Algorithm,
) -> Vec<u8> {
    let prk = hkdf::Prk::new_less_safe(hkdf, secret);

    let output_length_bytes = (key_type.len() as u16).to_be_bytes();
    let label = {
        let mut label_builder = Vec::new();
        label_builder.extend_from_slice(b"tls13 ");
        label_builder.extend_from_slice(label);
        label_builder
    };
    let label_bytes = label.len() as u8;

    let context_bytes = context.len() as u8;
    let label = [
        output_length_bytes.as_slice(),
        &[label_bytes],
        &label,
        &[context_bytes],
        context,
    ];

    let mut key = vec![0; key_type.len()];
    let out = prk.expand(&label, key_type).unwrap();
    out.fill(&mut key).unwrap();
    key
}

trait KeySpaceTrait {
    fn new(secret: &[u8]) -> Self;

    fn decrypt_record(&mut self, record: &[u8]);
}

impl KeySpace {
    fn new(client_secret: Vec<u8>, server_secret: Vec<u8>, cipher: iana::Cipher) -> Self {
        // https://www.rfc-editor.org/rfc/rfc8446#section-7.3
        // [sender]_write_key = HKDF-Expand-Label(Secret, "key", "", key_length)
        // [sender]_write_iv  = HKDF-Expand-Label(Secret, "iv", "", iv_length)

        Self {
            cipher,
            client_secret,
            server_secret,
            client_record_count: 0,
            server_record_count: 0,
        }
    }

    fn traffic_key(&self, mode: Mode) -> std::io::Result<(Vec<u8>, Vec<u8>)> {
        let secret = match mode {
            Mode::Client => self.client_secret.as_slice(),
            Mode::Server => self.server_secret.as_slice(),
        };
        // Determine the hash algorithm, key length, and IV length based on the cipher suite
        let aead = self.cipher.aead();

        let key = hkdf_expand_label(
            secret,
            b"key",
            b"",
            UsizeContainer::new(aead.key_len()),
            self.cipher.hkdf(),
        );
        let iv = hkdf_expand_label(
            secret,
            b"iv",
            b"",
            UsizeContainer::new(aead.nonce_len()),
            self.cipher.hkdf(),
        );

        Ok((key, iv))
    }

    /// * `record`: the encrypted record, exclusive of the header
    /// * `sender`: the party who transmitted the record
    fn decrypt_record(&mut self, header: &RecordHeader, record: &[u8], sender: Mode) -> Vec<u8> {
        let (key, iv) = self.traffic_key(sender).unwrap();

        let record_count = match sender {
            Mode::Client => &mut self.client_record_count,
            Mode::Server => &mut self.server_record_count,
        };
        let nonce = Self::calculate_nonce(iv, *record_count);
        *record_count += 1;

        let unbound_key = aws_lc_rs::aead::UnboundKey::new(self.cipher.aead(), &key).unwrap();
        let less_safe_key = aws_lc_rs::aead::LessSafeKey::new(unbound_key);

        // Create a buffer that contains ciphertext + tag for in-place decryption
        let mut output = record.to_vec();

        // Decrypt the record
        let nonce_obj = aws_lc_rs::aead::Nonce::try_assume_unique_for_key(&nonce).unwrap();

        let aad = header.encode_to_vec().unwrap();

        let plaintext = less_safe_key
            .open_in_place(nonce_obj, aws_lc_rs::aead::Aad::from(aad), &mut output)
            .unwrap();
        plaintext.to_vec()
    }

    /// XOR the IV with the record count
    fn calculate_nonce(iv: Vec<u8>, record_count: u64) -> Vec<u8> {
        let mut nonce = iv.clone();
        let record_count = record_count.to_be_bytes();
        let mut bytes = vec![0; nonce.len() - record_count.len()];
        bytes.extend_from_slice(&record_count);

        for i in 0..nonce.len() {
            nonce[i] ^= bytes[i];
        }

        nonce
    }
}

struct StreamDecrypter {
    /// The identity of this decrypter, either "client" or "server".
    ///
    /// We need to track this because we need to map send/recv data onto client/server
    /// specific keys.
    ///
    /// This is deduced from first IO. If the first IO is receiving, then we are
    /// a server. If the first IO is sending, then we are a client.
    pub identity: Option<Mode>,
    pub client_random: Option<Vec<u8>>,

    pub selected_cipher: Option<iana::Cipher>,
    pub selected_protocol: Option<Protocol>,

    /// all tx calls are buffered here until there is enough to read a message
    pub raw_server_tx: Vec<u8>,
    pub raw_client_tx: Vec<u8>,

    /// records, populated from tx
    pub server_record_tx: Vec<Vec<u8>>,
    pub client_record_tx: Vec<Vec<u8>>,

    // these are the "real" send and read callbacks that the client wants to use.
    // In the case of s2n-tls, I plan to steal them from inside the bindings.
    pub intercepted_send: Box<dyn std::io::Write>,
    pub intercepted_read: Box<dyn std::io::Read>,

    pub key_manager: KeyManager,
    // TODO: 2 different key spaces for client and server. They could stack key
    // updates on top of each other and we need to be able to handle that.
    pub current_space: Option<KeySpace>,

    pub handshake_message: Vec<(Mode, HandshakeMessageValue)>,
}

impl Debug for StreamDecrypter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("StreamDecrypter")
            .field("raw_client_tx", &self.raw_client_tx.len())
            .field("raw_server_tx", &self.raw_server_tx.len())
            .field("client_record_tx", &self.client_record_tx.len())
            .field("server_record_tx", &self.server_record_tx.len())
            .finish()
    }
}

impl StreamDecrypter {
    fn new(send: Box<dyn std::io::Write>, read: Box<dyn std::io::Read>, key_manager: KeyManager) -> Self {
        Self {
            identity: None,
            client_random: None,
            selected_cipher: None,
            selected_protocol: None,
            raw_server_tx: Vec::new(),
            raw_client_tx: Vec::new(),
            server_record_tx: Vec::new(),
            client_record_tx: Vec::new(),
            intercepted_send: send,
            intercepted_read: read,
            key_manager: key_manager,
            current_space: None,
            handshake_message: Vec::new(),
        }
    }

    fn assemble_records(&mut self, mode: Mode) -> std::io::Result<()> {
        // TODO: error handling. We currently assume that all errors are just because
        // there isn't enough data. Which will not be true into the future. Also
        // should think more about the "not enough data" error.

        let (raw, records) = match mode {
            Mode::Client => (&mut self.raw_client_tx, &mut self.client_record_tx),
            Mode::Server => (&mut self.raw_server_tx, &mut self.server_record_tx),
        };

        // multiple records may have been sent, so loop
        loop {
            let buffer = raw.as_slice();
            let (record_header, buffer) = RecordHeader::decode_from(buffer)?;
            if buffer.len() >= record_header.record_length as usize {
                // TODO: use split off for better performance
                let (record_contents, remaining) =
                    raw.split_at(5 + record_header.record_length as usize);
                records.push(record_contents.to_vec());
                *raw = remaining.to_vec();
            } else {
                // there wasn't enough to get the full record
                break;
            }
        }

        Ok(())
    }

    fn decrypt_records(&mut self, mode: Mode) -> std::io::Result<()> {
        // for each record
        println!("------------ {mode:?} ------------");
        let records = match mode {
            Mode::Client => &mut self.client_record_tx,
            Mode::Server => &mut self.server_record_tx,
        };

        for record in records.drain(..) {
            let record_buffer = record.as_slice();
            let (record_header, mut record_buffer) = RecordHeader::decode_from(record_buffer)?;
            println!("{record_header:#?}");

            // read all of the messages in the buffer
            while !record_buffer.is_empty() {
                record_buffer = match record_header.content_type {
                    ContentType::Invalid => panic!("invalid content"),
                    ContentType::ChangeCipherSpec => {
                        let (ccs, record_buffer) = ChangeCipherSpec::decode_from(record_buffer)?;
                        println!("{ccs:?}");
                        record_buffer
                    }
                    ContentType::Alert => {
                        let (alert, record_buffer) = Alert::decode_from(record_buffer)?;
                        println!("{alert:?}");
                        record_buffer
                    }
                    ContentType::Handshake => {
                        let (handshake_message, record_buffer) =
                            match (self.selected_protocol, self.selected_cipher) {
                                (Some(protocol), Some(cipher)) => {
                                    HandshakeMessageValue::decode_from_with_context(
                                        record_buffer,
                                        (protocol, cipher),
                                    )?
                                }
                                _ => HandshakeMessageValue::decode_from(record_buffer)?,
                            };

                        // extra the client random from the client hello
                        if let HandshakeMessageValue::ClientHello(ch) = &handshake_message {
                            self.client_random = Some(ch.random.to_vec())
                        }

                        // the server hello sets most of the relevant cryptographic state
                        if let HandshakeMessageValue::ServerHello(sh) = &handshake_message {
                            self.selected_cipher = Some(sh.cipher_suite);
                            self.selected_protocol = Some(sh.selected_version()?);
                        }

                        println!("{handshake_message:?}");
                        self.handshake_message.push((mode, handshake_message));

                        record_buffer
                    }
                    ContentType::ApplicationData => {
                        // TODO: I think I need two separate spaces.
                        if self.current_space.is_none() {
                            self.current_space = self
                                .key_manager
                                .handshake_space(self.client_random.as_ref().unwrap(), self.selected_cipher.unwrap());
                        }
                        // check if keys are available
                        // if let Some(space) = self
                        //     .key_manager
                        //     .handshake_space(self.selected_cipher.unwrap())
                        // {
                        //     self.current_space = Some(space);
                        // }

                        println!("{} bytes of ApplicationData", record_buffer.len());
                        let space = self.current_space.as_mut().unwrap();
                        let mut plaintext =
                            space.decrypt_record(&record_header, record_buffer, mode);

                        // TODO explain wth is happening here.
                        let mut padding = 0;
                        while plaintext.ends_with(&[0]) {
                            padding += 1;
                            plaintext.remove(plaintext.len() - 1);
                        }

                        let (content_type, _buffer) =
                            ContentType::decode_from(&plaintext[plaintext.len() - 1..])?;

                        println!("InnerRecordHeader {{");
                        println!("    content_type: {content_type:?}");
                        println!("    inner_length: {}", plaintext.len() - 1);
                        println!("    padding: {padding}");
                        println!("}}");
                        let inner_buffer = plaintext.as_slice();
                        let (handshake_message, inner_buffer) =
                            match (self.selected_protocol, self.selected_cipher) {
                                (Some(protocol), Some(cipher)) => {
                                    HandshakeMessageValue::decode_from_with_context(
                                        inner_buffer,
                                        (protocol, cipher),
                                    )?
                                }
                                _ => HandshakeMessageValue::decode_from(inner_buffer)?,
                            };
                        println!("{handshake_message:#?}");
                        // if it was the client finished, time for application secrets
                        if matches!(handshake_message, HandshakeMessageValue::Finished(_))
                            && mode == Mode::Client
                        {
                            self.current_space = self
                                .key_manager
                                .application_space(self.client_random.as_ref().unwrap(), self.selected_cipher.unwrap());
                        }
                        self.handshake_message.push((mode, handshake_message));

                        &[]
                    }
                };
            }
        }

        Ok(())
    }
}

// designed to work with an IO callback based pattern, such as that used by s2n-tls
// and OpenSSL
impl std::io::Read for StreamDecrypter {
    fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
        if self.identity.is_none() {
            // reading first is server behavior
            self.identity = Some(Mode::Server);
        }

        let read = self.intercepted_read.read(buf)?;

        match self.identity.unwrap() {
            Mode::Client => self.raw_server_tx.extend_from_slice(&buf[..read]),
            Mode::Server => self.raw_client_tx.extend_from_slice(&buf[..read]),
        }

        let peer = self.identity.unwrap().peer();
        self.assemble_records(peer);
        self.decrypt_records(peer);

        Ok(read)
    }
}

impl std::io::Write for StreamDecrypter {
    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
        if self.identity.is_none() {
            // writing first is client behavior
            self.identity = Some(Mode::Client);
        }

        let written = self.intercepted_send.write(buf)?;

        match self.identity.unwrap() {
            Mode::Client => self.raw_client_tx.extend_from_slice(&buf[..written]),
            Mode::Server => self.raw_server_tx.extend_from_slice(&buf[..written]),
        }

        self.assemble_records(self.identity.unwrap());
        self.decrypt_records(self.identity.unwrap());

        Ok(written)
    }

    fn flush(&mut self) -> std::io::Result<()> {
        /* no op */
        Ok(())
    }
}

#[cfg(test)]
mod s2n_tls_decryption {
    use crate::{
        decryption::s2n_tls_intercept::{
            generic_recv_cb, generic_send_cb, intercept_recv_callback, intercept_send_callback,
        },
        protocol::HandshakeMessageHeader,
    };

    use super::*;

    use std::ffi::c_void;

    use s2n_tls::testing::TestPair;

    pub fn s2n_server_config(
        security_policy: &str,
        cert_type: &[SigType],
    ) -> Result<s2n_tls::config::Builder, Box<dyn std::error::Error>> {
        let policy = s2n_tls::security::Policy::from_version(security_policy)?;

        let mut builder = s2n_tls::config::Config::builder();
        builder.with_system_certs(false)?;
        builder.set_security_policy(&policy)?;
        builder.set_max_blinding_delay(0)?;

        unsafe { builder.disable_x509_verification().unwrap() };

        for ct in cert_type {
            builder.trust_pem(&read_to_bytes(PemType::CACert, *ct))?;
            let cert = read_to_bytes(PemType::ServerCertChain, *ct);
            let key = read_to_bytes(PemType::ServerKey, *ct);
            builder.load_pem(&cert, &key)?;
        }

        Ok(builder)
    }

    #[derive(Clone, Copy, strum::EnumIter)]
    pub enum PemType {
        ServerKey,
        ServerCertChain,
        ClientKey,
        ClientCertChain,
        CACert,
    }

    impl PemType {
        fn get_filename(&self) -> &str {
            match self {
                PemType::ServerKey => "server-key.pem",
                PemType::ServerCertChain => "server-chain.pem",
                PemType::ClientKey => "client-key.pem",
                PemType::ClientCertChain => "client-cert.pem",
                PemType::CACert => "ca-cert.pem",
            }
        }
    }

    #[derive(Clone, Copy, Default, strum::EnumIter)]
    pub enum SigType {
        Rsa2048,
        Rsa3072,
        Rsa4096,
        #[default]
        Ecdsa384,
        Ecdsa256,
        Ecdsa521,
        Rsassa2048,
    }

    impl SigType {
        pub fn get_dir_name(&self) -> &str {
            match self {
                SigType::Rsa2048 => "rsa2048",
                SigType::Rsa3072 => "rsa3072",
                SigType::Rsa4096 => "rsa4096",
                SigType::Rsassa2048 => "rsapss2048",
                SigType::Ecdsa256 => "ecdsa256",
                SigType::Ecdsa384 => "ecdsa384",
                SigType::Ecdsa521 => "ecdsa521",
            }
        }
    }

    pub fn get_cert_path(pem_type: PemType, sig_type: SigType) -> String {
        format!(
            "certs/{}/{}",
            sig_type.get_dir_name(),
            pem_type.get_filename()
        )
    }

    fn read_to_bytes(pem_type: PemType, sig_type: SigType) -> Vec<u8> {
        std::fs::read_to_string(get_cert_path(pem_type, sig_type))
            .unwrap()
            .into_bytes()
    }

    #[test]
    fn s2n_server_test() -> anyhow::Result<()> {
        // 1 key logger
        // 2 config
        // 3 test pair
        // 4 intercepted callbacks
        // 5 decrypted

        let key_manager = KeyManager::new();

        let client_config = s2n_server_config("default_tls13", &[SigType::Rsa3072]).unwrap();
        let mut server_config = s2n_server_config("default_tls13", &[SigType::Rsa3072]).unwrap();
        unsafe {
            server_config.set_key_log_callback(
                Some(KeyManager::key_log_cb),
                &key_manager as *const KeyManager as *mut c_void,
            )?
        };
        let mut test_pair =
            TestPair::from_configs(&client_config.build()?, &server_config.build()?);

        test_pair
            .client
            .set_server_name("omgðŸ’…heyyyâœ¨bestieðŸ’–letsðŸ‘ªdoðŸ’ŒtlsðŸ”’")
            .unwrap();

        // let server send_cb
        let send = intercept_send_callback(&test_pair, s2n_tls::enums::Mode::Server);
        let recv = intercept_recv_callback(&test_pair, s2n_tls::enums::Mode::Server);

        let stream_decrypter = StreamDecrypter {
            identity: None,
            client_random: None,
            intercepted_send: Box::new(send),
            intercepted_read: Box::new(recv),
            selected_cipher: None,
            selected_protocol: None,
            key_manager,
            raw_server_tx: Vec::new(),
            raw_client_tx: Vec::new(),
            server_record_tx: Vec::new(),
            client_record_tx: Vec::new(),
            current_space: None,
            handshake_message: Vec::new(),
        };

        let stream_decrypter = Box::new(stream_decrypter);
        test_pair
            .server
            .set_send_callback(Some(generic_send_cb::<StreamDecrypter>))?;
        test_pair
            .server
            .set_receive_callback(Some(generic_recv_cb::<StreamDecrypter>))?;
        unsafe {
            test_pair.server.set_send_context(
                stream_decrypter.as_ref() as *const StreamDecrypter as *mut c_void,
            )?;
            test_pair
                .server
                .set_receive_context(
                    stream_decrypter.as_ref() as *const StreamDecrypter as *mut c_void
                )?;
        }

        test_pair.handshake().unwrap();
        test_pair.client.poll_shutdown_send();
        test_pair.server.poll_shutdown_send();
        let mut messages = stream_decrypter.handshake_message;
        println!("{:?}", messages);
        // should just use vec deque
        messages.reverse();

        let (sender, message) = messages.pop().unwrap();
        assert_eq!(sender, Mode::Client);
        assert!(matches!(message, HandshakeMessageValue::ClientHello(_)));

        let (sender, message) = messages.pop().unwrap();
        assert_eq!(sender, Mode::Server);
        assert!(matches!(message, HandshakeMessageValue::ServerHello(_)));

        let (sender, message) = messages.pop().unwrap();
        assert_eq!(sender, Mode::Server);
        assert!(matches!(
            message,
            HandshakeMessageValue::EncryptedExtensions(_)
        ));

        let (sender, message) = messages.pop().unwrap();
        assert_eq!(sender, Mode::Server);
        assert!(matches!(
            message,
            HandshakeMessageValue::CertificateTls13(_)
        ));

        let (sender, message) = messages.pop().unwrap();
        assert_eq!(sender, Mode::Server);
        assert!(matches!(message, HandshakeMessageValue::CertVerifyTls13(_)));

        let (sender, message) = messages.pop().unwrap();
        assert_eq!(sender, Mode::Server);
        assert!(matches!(message, HandshakeMessageValue::Finished(_)));

        let (sender, message) = messages.pop().unwrap();
        assert_eq!(sender, Mode::Client);
        assert!(matches!(message, HandshakeMessageValue::Finished(_)));

        Ok(())
    }

    #[test]
    fn traffic_key_derivation() {
        let server_secret =
            hex::decode("4182e4b0b6565a8f7b8586cc35d2ca23f22fa47764a16eaee9e1b21038efd2a4")
                .unwrap();
        let client_secret =
            hex::decode("8bf4b07633e7de6b46e2a680713d8b0b8b9bcc9592163b8fa32222d650b005f3")
                .unwrap();

        let space = KeySpace::new(
            client_secret,
            server_secret,
            iana::Cipher::from_description("TLS_AES_128_GCM_SHA256").unwrap(),
        );

        let (key, iv) = space.traffic_key(Mode::Server).unwrap();
        assert_eq!(hex::encode(key), "d4af18cdaa11d3943b4d8bb0f9d6c6ca");
        assert_eq!(hex::encode(iv), "32bd8d44d91fb6e913c3349b");
    }

    #[test]
    fn handshake_record_decrypt() {
        let server_secret =
            hex::decode("64d7b60c7f0d3ca90e47411c575f7eaa8b24d754f3e68ac2d3f060e28395553d")
                .unwrap();
        let client_secret =
            hex::decode("8bf4b07633e7de6b46e2a680713d8b0b8b9bcc9592163b8fa32222d650b005f3")
                .unwrap();

        let aes_128 = iana::Cipher::from_description("TLS_AES_128_GCM_SHA256").unwrap();

        let mut space = KeySpace::new(client_secret, server_secret, aes_128);

        let record =
            hex::decode("1703030017c89a8a469e34ecee23cd8fbe8e978763ac2e498ddebcc5").unwrap();
        let record_buffer = record.as_slice();
        let (record_header, record_buffer) = RecordHeader::decode_from(record_buffer).unwrap();

        let decrypted = space.decrypt_record(&record_header, record_buffer, Mode::Server);
        assert_eq!(hex::encode(decrypted), "08000002000016");
    }

    #[test]
    fn maybe_app_data() {
        let data = hex::decode("08000002000016").unwrap();

        let (header, buffer) = HandshakeMessageHeader::decode_from(data.as_slice()).unwrap();
        println!("header : {header:#?}");
    }
}
